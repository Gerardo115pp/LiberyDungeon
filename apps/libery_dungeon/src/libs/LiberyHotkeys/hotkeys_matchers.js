/*=============================================
=            KEY MAPS            =
=============================================*/

    /*----------  Key values for keyboard events  ----------*/
    // See: https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values

    export const letter_keys = new Set([
        "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
        "k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
        "u", "v", "w", "x", "y", "z"
    ]);

    export const upper_letter_hotkeys = new Set([
        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
        "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
        "U", "V", "W", "X", "Y", "Z"
    ]);

    export const number_hotkeys = new Set([
        "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
    ]);

    export const character_producing_hotkeys = new Set([
        "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"
    ]);

    export const whitespace_hotkeys = new Set([
        " ", "space", "Tab", "Enter"
    ]);

    export const modifier_keys = new Set([
        "Alt", "AltGraph", "CapsLock", "Control", "Fn", 
        "FnLock", "Hyper", "Meta", "NumLock", "ScrollLock",
        "Shift", "Super", "Symbol", "SymbolLock"
    ]);

    export const navigation_keys = new Set([
        "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp",
        "End", "Home", "PageDown", "PageUp"
    ]);


    export const editing_keys = new Set([
        "Backspace", "Clear", "Copy", "CrSel", "Cut", "Delete",
        "EraseEof", "ExSel", "Insert", "Paste", "Redo", "Undo"
    ]);

    export const function_keys = new Set([
        "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10",
        "F11", "F12"
    ]);


    
    /*----------  Code values for keyboard events  ----------*/
        // The KeyboardEvent.code property represents a physical key on the keyboard (as opposed to the character generated by pressing the key). In other words, 
        // this property returns a value that isn't altered by keyboard layout or the state of the modifier keys
        // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
    
        export const letter_codes = new Set([
            "KeyA", "KeyB", "KeyC", "KeyD", "KeyE", "KeyF", "KeyG", "KeyH", "KeyI", "KeyJ",
            "KeyK", "KeyL", "KeyM", "KeyN", "KeyO", "KeyP", "KeyQ", "KeyR", "KeyS", "KeyT",
            "KeyU", "KeyV", "KeyW", "KeyX", "KeyY", "KeyZ"
        ]);

        export const number_codes = new Set([
            "Digit0", "Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6", "Digit7", "Digit8", "Digit9"
        ]);

        export const whitespace_codes = new Set([
            "Space", "Tab", "Enter"
        ]);

    
    /*----------  Hotkey alias  ----------*/
        // These are the names we use to refer to specific keys and metakeys. these are the hotkey fragments that are expected on key combos. e.g: "ctrl+shift+a", "c c", "\d x", etc.

        export const SHIFT_KEY = "shift";
        export const CONTROL_KEY = "ctrl";
        export const COMMAND_KEY = "cmd";
        export const ALT_KEY = "alt";
        export const OPTIONS_KEY = "opt";
        export const ESCAPE_KEY = "esc";
        export const ENTER_KEY = "enter";
        export const SPACE_KEY = "space";
        export const TAB_KEY = "tab";
        export const BACKSPACE_KEY = "backspace";
        export const DELETE_KEY = "del";
        export const INSERT_KEY = "ins";
        export const HOME_KEY = "home";
        export const END_KEY = "end";
        export const PAGE_UP_KEY = "pgup";
        export const PAGE_DOWN_KEY = "pgdown";
        export const ARROW_UP_KEY = "up";
        export const ARROW_DOWN_KEY = "down";
        export const ARROW_LEFT_KEY = "left";
        export const ARROW_RIGHT_KEY = "right";
        export const CAPS_LOCK_KEY = "caps";
        export const NUM_LOCK_KEY = "num";
        export const SCROLL_LOCK_KEY = "scroll";

        export const F1_KEY = "f1";
        export const F2_KEY = "f2";
        export const F3_KEY = "f3";
        export const F4_KEY = "f4";
        export const F5_KEY = "f5";
        export const F6_KEY = "f6";
        export const F7_KEY = "f7";
        export const F8_KEY = "f8";
        export const F9_KEY = "f9";
        export const F10_KEY = "f10";
        export const F11_KEY = "f11";
        export const F12_KEY = "f12";

        // Multi match keys
        export const NUMERIC_KEY = "\\d";
        export const LETTER_KEY = "\\w";

        export const valid_fragment_identities = new Set([
            ESCAPE_KEY, ENTER_KEY, SPACE_KEY, TAB_KEY, BACKSPACE_KEY, DELETE_KEY, INSERT_KEY,
            HOME_KEY, END_KEY, PAGE_UP_KEY, PAGE_DOWN_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, ARROW_LEFT_KEY,
            ARROW_RIGHT_KEY, CAPS_LOCK_KEY, NUM_LOCK_KEY, SCROLL_LOCK_KEY, NUMERIC_KEY, LETTER_KEY,
            F1_KEY, F2_KEY, F3_KEY, F4_KEY, F5_KEY, F6_KEY, F7_KEY, F8_KEY, F9_KEY, F10_KEY, F11_KEY, F12_KEY
        ]);

/*=====  End of KEY MAPS  ======*/

/*=============================================
=            Matchers            =
=============================================*/

    /**
     * Returns true if the passed key is a valid hotkey identity. E.g: imagine a hotkey like "ctrl+shift+a", it's valid hotkey identity would be the "a" 
     * because it's not a modifier key and it is present in normal keyboard layouts(by normal i mean it's not exclusive of virtual keyboards).
     * other examples would be: "ctrl+[" -> "[", "ctrl+shift+1" -> "1", "b" -> "b", "ctrl+shift+alt+space" -> "space"
     * @param {string} key
     * @returns {boolean}
     */
    const isHotkeyIdentity = (key) => {
        let is_modifier = modifier_keys.has(key);

        if (is_modifier) return false;

        let key_in_uppercase = key.toUpperCase(); // Have normalized versions of the key for better matching
        let key_in_lowercase = key.toLowerCase();

        let is_letter = letter_keys.has(key_in_lowercase);

        let is_number = number_hotkeys.has(key);

        let is_special_character = character_producing_hotkeys.has(key);

        let is_other_valid_identity = valid_fragment_identities.has(key);

        return is_letter || is_number || is_special_character || is_other_valid_identity;
    }

/*=====  End of Matchers  ======*/

/**
* For reference different types of hotkeys would be:
 * "shift+x" is a key fragment.
 * "c c" is a key sequence. which has two key fragments.
 * "gZ" is a key chord. and is never spelled as a combo. For this you spell a combo 'g' and bind register it as a Chord passing it not a handler function, but a different hotkey context, which as soon as any key is pressed will 
 *      either trigger the chord if the next key is in the context or reset the previous context that contained the chord if it is not.
*/

/**
 * Represents a piece of a hotkey, by this i mean if there is a hotkey such as 'ctrl+k ctrl+t' this entire hotkey will be composed from two fragments: 'ctrl+k' and 'ctrl+t'
 * TODO: Right now fragments like 'a+x' are not supported. But this is planned to have support as soon as i can replace at least the features Mousetrap provides. and from there i will start adding more features.
 */
export class HotkeyFragment {
    /**
     * the hotkey fragment like "ctrl+shift+a"
     * @type {string} 
     */
    #fragment

    /**
     * The fragment members. if we use the same example "ctrl+shift+a" the members will be ["ctrl", "shift", "a"]
     * @type {string[]} 
     */
    #fragment_members

    /**
     * The fragment identity. this is the key that would be passed on a KeyboardEvent.key property. e.g: "a" in "ctrl+shift+a"
     */
    #fragment_identity

    /**
     * Whether the key requires control modifier.
     * @type {boolean} 
     */
    #control_modifier

    /**
     * Whether the key requires shift modifier.
     * @type {boolean} 
     */
    #shift_modifier

    /**
     * Whether the key requires alt modifier.
     * @type {boolean} 
     */
    #alt_modifier

    /**
     * @param {string} fragment the hotkey fragment. e.g: "ctrl+shift+a", "a", "ctrl+a", 
     */
    constructor(fragment) {
        this.#fragment = fragment;
        this.#fragment_members = this.#splitFragment();

        this.#control_modifier = false;
        this.#shift_modifier = false;
        this.#alt_modifier = false;

        this.#fragment_identity = "";

        this.#parseModifiers();
    }

    /**
     * Detects the role a member has in the fragment. 
     * if its a modifier it will set the corresponding modifier flag.
     * @param {string} member
     */
    #detectMemberRole(member) {
        let valid_member = false;
        let is_control = false;
        let is_shift = false;
        let is_alt = false;

        if (!this.#control_modifier) {
            this.#control_modifier = member === CONTROL_KEY || member === COMMAND_KEY;
            is_control = this.#control_modifier;
            valid_member = is_control;
        }

        if (!this.#shift_modifier && !valid_member) {
            this.#shift_modifier = member === SHIFT_KEY;
            is_shift = this.#shift_modifier;
            valid_member = is_shift;
        }

        if (!this.#alt_modifier && !valid_member) {
            this.#alt_modifier = this.#alt_modifier || member === ALT_KEY || member === OPTIONS_KEY;
            is_alt = this.#alt_modifier;
            valid_member = is_alt;
        }

        if (!is_control && !is_shift && !is_alt && !valid_member) {
            valid_member = isHotkeyIdentity(member);

            if (valid_member) {
                if (this.#fragment_identity === "") {
                    this.#fragment_identity = member;
                } else {
                    console.warn(`Fragment of the type x+y, which seems to match '${this.#fragment}', are not yet stable. just be aware of this.`);
                }
            }
        }

        if (!valid_member) {
            throw new Error(`Invalid hotkey fragment<${this.#fragment}> has invalid member '${member}'`);
        }
    }

    /**
     * The fragment's identity. this is the key that would be passed on a KeyboardEvent.key property. e.g: "a" in "ctrl+shift+a"
     * @returns {string}
     */
    get Identity() {
        return this.#fragment_identity;
    }

    /**
     * Matches the hotkey fragment with a given KeyboardEvent
     * @param {KeyboardEvent} event
     * @returns {boolean}
     */
    match(event) {
        let matched = true;
        
        if (!this.#matchIdentity(event)) {
            matched = false;
        }

        if (matched && this.#control_modifier) {
            matched = event.ctrlKey;
        }

        if (matched && this.#shift_modifier) {
            matched = event.shiftKey;
        }

        if (matched && this.#alt_modifier) {
            matched = event.altKey;
        }

        return matched;
    }

    /**
     * Matches the identity of the fragment against the passed KeyboardEvent. considering how modifiers would affect the match.
     * @param {KeyboardEvent} event
     */
    #matchIdentity(event) {
        let key = event.key;

        if (this.#shift_modifier) {
            key = key.toLowerCase();
        }

        return key === this.#fragment_identity;
    }

    /**
     * Splits the fragment into its members
     * @returns {string[]} the fragment members
     */
    #splitFragment() {
        return this.#fragment.split("+");
    }

    #parseModifiers() {
        for (const member of this.#fragment_members) {
            this.#detectMemberRole(member);
        }
    }
}